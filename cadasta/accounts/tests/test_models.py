import pytest

from datetime import datetime
from django.conf import settings
from django.test import TestCase
from .factories import UserFactory
from core.tests.utils.cases import UserTestCase
from unittest import mock
from django.db import IntegrityError
from ..models import VerificationDevice


class UserTest(TestCase):
    def test_repr(self):
        date = datetime.now()
        user = UserFactory.build(username='John',
                                 full_name='John Lennon',
                                 email='john@beatles.uk',
                                 email_verified=True,
                                 phone='+12025550111',
                                 phone_verified=True)
        assert repr(user) == ('<User username=John'
                              ' full_name=John Lennon'
                              ' email=john@beatles.uk'
                              ' email_verified=True'
                              ' phone=+12025550111'
                              ' phone_verified=True>').format(date)

    def test_avatar_url_property_with_avatar_field_empty(self):
        user = UserFactory.build(username='John',
                                 full_name='John Lennon',
                                 email='john@beatles.uk',
                                 )
        assert user.avatar_url == settings.DEFAULT_AVATAR

    def test_avatar_url_property_with_avatar_field_set(self):
        test_avatar_path = '/accounts/tests/files/avatar.png'
        user = UserFactory.build(username='John',
                                 full_name='John Lennon',
                                 email='john@beatles.uk',
                                 avatar=test_avatar_path,
                                 )
        assert user.avatar_url == user.avatar.url


class VerificationDeviceTest(UserTestCase, TestCase):
    def setUp(self):
        super().setUp()

        self.sherlock = UserFactory.create(username='sherlock')
        VerificationDevice.objects.create(
            user=self.sherlock,
            unverified_phone=self.sherlock.phone)

        self.john = UserFactory.create(username='john')
        VerificationDevice.objects.create(
            user=self.john,
            unverified_phone=self.john.phone)

        self.TOTP_TOKEN_VALIDITY = settings.TOTP_TOKEN_VALIDITY
        self._now = 1497657600

    def test_instant(self):
        """Verify token as soon as it is created"""
        device = self.sherlock.verificationdevice
        with mock.patch('time.time', return_value=self._now):
            token = device.generate_challenge()
            verified = device.verify_token(int(token))

        assert verified is True

    def test_barely_made_it(self):
        """Verify token 1 second before it expires"""
        device = self.sherlock.verificationdevice

        with mock.patch('time.time', return_value=self._now):
            token = device.generate_challenge()
        with mock.patch('time.time',
                        return_value=self._now + self.TOTP_TOKEN_VALIDITY - 1):
            verified = device.verify_token(int(token))

        assert verified is True

    def test_too_late(self):
        """Verify token 1 second after it expires"""
        device = self.sherlock.verificationdevice

        with mock.patch('time.time', return_value=self._now):
            token = device.generate_challenge()
        with mock.patch('time.time',
                        return_value=self._now + self.TOTP_TOKEN_VALIDITY + 1):
            verified = device.verify_token(int(token))

        assert verified is False

    def test_future(self):
        """Verify token from the future. Time Travel!!"""
        device = self.sherlock.verificationdevice

        with mock.patch('time.time', return_value=self._now + 1):
            token = device.generate_challenge()
        with mock.patch('time.time', return_value=self._now - 1):
            verified = device.verify_token(int(token))

        assert verified is False

    def test_code_reuse(self):
        """Verify same token twice"""
        device = self.sherlock.verificationdevice

        with mock.patch('time.time', return_value=self._now):
            token = device.generate_challenge()
            verified_once = device.verify_token(int(token))
            verified_twice = device.verify_token(int(token))

        assert verified_once is True
        assert verified_twice is False

    def test_cross_user(self):
        """Verify token generated by one device with that of another"""
        device_sherlock = self.sherlock.verificationdevice
        device_john = self.john.verificationdevice

        with mock.patch('time.time', return_value=self._now):
            token = device_sherlock.generate_challenge()
            verified = device_john.verify_token(int(token))

        assert verified is False

    def test_create_two_devices_for_same_user(self):
        """Try to create 2 device for same user"""
        self.moriarty = UserFactory.create(username="jim")
        VerificationDevice.objects.create(user=self.moriarty,
                                          unverified_phone=self.moriarty.phone)
        with pytest.raises(IntegrityError):
            VerificationDevice.objects.create(
                user=self.moriarty,
                unverified_phone='+919067439937')
            self.sherlock.save()

    def test_create_two_devices_with_same_number(self):
        """Try to create 2 devices with same phone number"""
        self.moriarty = UserFactory.create(username='jim')
        with pytest.raises(IntegrityError):
            VerificationDevice.objects.create(
                user=self.moriarty,
                unverified_phone=self.sherlock.phone)

    def test_token_tolerance(self):
        """Test tolerance of a token"""
        device = self.sherlock.verificationdevice
        with mock.patch('time.time', return_value=(
                self._now + (settings.TOTP_TOKEN_VALIDITY * 2))):
            token = device.generate_challenge()
        with mock.patch('time.time', return_value=self._now):
            verified = device.verify_token(token=int(token), tolerance=2)

        assert verified is True
