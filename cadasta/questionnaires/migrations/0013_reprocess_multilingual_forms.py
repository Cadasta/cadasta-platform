# -*- coding: utf-8 -*-
# Generated by Django 1.9.6 on 2016-10-12 12:51
from __future__ import unicode_literals

from django.db import migrations

import os.path
import re
import itertools
from lxml import etree
from pyxform.xls2json import parse_file_to_json
from pyxform.builder import create_survey_element_from_dict
from questionnaires.managers import (
    multilingual_label_check, check_for_language, fix_languages,
    ATTRIBUTE_GROUPS
)
from questionnaires.exceptions import InvalidXLSForm


def update_children(apps, children, errors=[], project=None,
                    default_language='', kwargs={}):
    QuestionGroup = apps.get_model('questionnaires', 'QuestionGroup')
    Question = apps.get_model('questionnaires', 'Question')
    ContentType = apps.get_model('contenttypes', 'ContentType')
    if children:
        for c in children:
            if c.get('type') == 'repeat':
                update_children(apps, c['children'], errors, project,
                                default_language, kwargs)
            elif c.get('type') == 'group':
                # parse attribute group
                attribute_group = c.get('name')
                for attr_group in ATTRIBUTE_GROUPS.keys():
                    if attribute_group.startswith(attr_group):
                        app_label = ATTRIBUTE_GROUPS[attr_group]['app_label']
                        model = ATTRIBUTE_GROUPS[attr_group]['model']
                        content_type = ContentType.objects.get(
                            app_label=app_label, model=model)
                        update_attrs_schema(
                            apps,
                            project=project, dict=c,
                            content_type=content_type,
                            default_language=default_language,
                            errors=errors
                        )

                qg = QuestionGroup.objects.get(name=c.get('name'), **kwargs)
                qg.label_xlat = c.get('label', {})
                qg.save()

                update_children(
                    apps,
                    children=c.get('children'),
                    errors=errors,
                    project=kwargs['questionnaire'].project,
                    kwargs={
                        'questionnaire': kwargs['questionnaire'],
                        'question_group': qg
                    }
                )
            else:
                q = Question.objects.get(name=c.get('name'), **kwargs)
                q.label_xlat = c.get('label', {})
                q.save()
                if q.type in ['S1', 'SM']:
                    update_options(apps, c.get('choices'), q, errors=errors)


def update_options(apps, options, question, errors=[]):
    if options:
        QuestionOption = apps.get_model('questionnaires', 'QuestionOption')
        for o, idx in zip(options, itertools.count()):
            qo = QuestionOption.objects.get(question=question, index=idx+1)
            qo.label_xlat = o['label']
            qo.save()
    else:
        errors.append("Please provide at least one option for field"
                      " '{field_name}'".format(field_name=question.name))


def lookup_schema(apps, content_type, selectors):
    selectors = tuple(selectors)

    Schema = apps.get_model('jsonattrs', 'Schema')
    base_schemas = Schema.objects.filter(content_type=content_type)
    schemas = []
    for i in range(len(selectors) + 1):
        schemas += list(base_schemas.filter(selectors=selectors[:i]))
    return schemas[0]


def update_attrs_schema(apps, project=None, dict=None, content_type=None,
                        default_language='', errors=[]):
    fields = []
    selectors = (project.organization.pk, project.pk,
                 project.current_questionnaire)
    # check if the attribute group has a relevant bind statement,
    # eg ${party_type}='IN'
    # this enables conditional attribute schema creation
    bind = dict.get('bind', None)
    if bind:
        relevant = bind.get('relevant', None)
        if relevant:
            clauses = relevant.split('=')
            selector = re.sub("'", '', clauses[1])
            selectors += (selector,)

    Attribute = apps.get_model('jsonattrs', 'Attribute')

    schema_obj = lookup_schema(apps, content_type, selectors)
    schema_obj.default_language = default_language
    schema_obj.save()

    for c in dict.get('children'):
        field = {}
        field['name'] = c.get('name')
        field['long_name'] = c.get('label')
        if c.get('choices'):
            field['choices'] = [choice.get('name')
                                for choice in c.get('choices')]
            field['choice_labels'] = [choice.get('label')
                                      for choice in c.get('choices')]
        fields.append(field)

    for field, index in zip(fields, itertools.count(1)):
        attr = Attribute.objects.get(schema=schema_obj, name=field['name'])
        attr.long_name_xlat = field.get('long_name', field['name'])
        attr.choice_labels_xlat = field.get('choice_labels', None)
        attr.save()


def reprocess_multilingual_forms(apps, schema_editor):
    Questionnaire = apps.get_model('questionnaires', 'Questionnaire')
    for quest in Questionnaire.objects.all():
        # Parse XLS form and check multilingual settings.
        try:
            json = parse_file_to_json(quest.xls_form.file.name)
        except:
            # Skip bad forms.
            continue
        has_default_language = (
            'default_language' in json and
            json['default_language'] != 'default'
        )
        if (has_default_language and
           not check_for_language(json['default_language'])):
            raise InvalidXLSForm(
                ["Default language code '{}' unknown".format(
                    json['default_language']
                )]
            )
        is_multilingual = multilingual_label_check(json['children'])
        if is_multilingual and not has_default_language:
            raise InvalidXLSForm(["Multilingual XLS forms must have "
                                  "a default_language setting"])

        # Skip monolingual forms.  No changes needed here.
        if not is_multilingual:
            continue

        # Skip "left over" questionnaires.
        if quest.project.current_questionnaire != quest:
            continue

        # Set up default language: fix "default" where it crops up.
        quest.default_language = json['default_language']
        if quest.default_language == 'default':
            quest.default_language = ''

        # Recreate XML form with correct language labels.
        survey = create_survey_element_from_dict(json)
        xml_form = survey.xml()
        fix_languages(xml_form)
        xml_form = xml_form.toxml()
        # insert version attr into the xform instance root node
        xml = insert_version_attribute(
            xml_form, quest.filename, quest.version
        )
        name = os.path.join(quest.xml_form.field.upload_to,
                            os.path.basename(quest.filename))
        url = quest.xml_form.storage.save('{}.xml'.format(name), xml)
        quest.xml_form = url

        # Store updated default language and XML form information.
        quest.save()

        # Update from the top.
        errors = []
        update_children(
            apps,
            children=json.get('children'),
            errors=errors,
            project=quest.project,
            default_language=quest.default_language,
            kwargs={'questionnaire': quest}
        )


def insert_version_attribute(xform, root_node, version):
    ns = {'xf': 'http://www.w3.org/2002/xforms'}
    root = etree.fromstring(xform)
    inst = root.find(
        './/xf:instance/xf:{root_node}'.format(
            root_node=root_node
        ), namespaces=ns
    )
    inst.set('version', str(version))
    xml = etree.tostring(
        root, method='xml', encoding='utf-8', pretty_print=True
    )
    return xml


class Migration(migrations.Migration):

    dependencies = [
        ('questionnaires', '0012_remove_monolingual_labels'),
    ]

    operations = [
        migrations.RunPython(
            reprocess_multilingual_forms,
            reverse_code=migrations.RunPython.noop
        )
    ]
